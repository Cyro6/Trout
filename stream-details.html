<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Details</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
            font-size: 16px;
        }
        h1, h2, h3 {
            color: #333;
        }
        .back-link {
            margin-bottom: 20px;
        }
        a {
            color: #4CAF50;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .stats, .month-stats, .top-outings, .stream-info, .widnr-map-section, .weather-section {
            margin: 20px 0;
            padding: 15px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .stream-info p, .weather-section p {
            margin: 5px 0;
        }
        .widnr-map-section .toggle-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 3px;
            cursor: pointer;
            display: inline-block;
            margin-bottom: 10px;
        }
        .widnr-map-section .toggle-button:hover {
            background-color: #45a049;
        }
        .widnr-map-section .iframe-container {
            position: relative;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            height: 0;
            overflow: hidden;
            display: none; /* Collapsed by default */
        }
        .widnr-map-section .iframe-container.active {
            display: block;
        }
        .widnr-map-section .iframe-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
        }
        .widnr-map-section .iframe-fallback {
            margin-top: 10px;
            color: #555;
            display: none;
        }
        .widnr-map-section .iframe-fallback.active {
            display: block;
        }
        .spots-table, .top-outings-table, .month-outing-table, .weather-table {
            width: 100%;
            max-width: 800px;
            margin: 20px 0;
            border-collapse: collapse;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .spots-table th, .spots-table td, .top-outings-table th, .top-outings-table td, .month-outing-table th, .month-outing-table td, .weather-table th, .weather-table td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }
        .spots-table th, .top-outings-table th, .month-outing-table th, .weather-table th {
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
        }
        .spots-table th:hover, .top-outings-table th:hover, .month-outing-table th:hover, .weather-table th:hover {
            background-color: #45a049;
        }
        .spots-table th.sort-asc::after, .top-outings-table th.sort-asc::after, .month-outing-table th.sort-asc::after {
            content: ' ↑';
        }
        .spots-table th.sort-desc::after, .top-outings-table th.sort-desc::after, .month-outing-table th.sort-desc::after {
            content: ' ↓';
        }
        .spots-table tr:nth-child(even), .top-outings-table tr:nth-child(even), .month-outing-table tr:nth-child(even), .weather-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .spots-table tr:hover, .top-outings-table tr:hover, .month-outing-table tr:hover, .weather-table tr:hover {
            background-color: #f1f1f1;
        }
        .loading {
            text-align: center;
            font-size: 1.2em;
            color: #555;
        }
        .error {
            text-align: center;
            color: red;
        }
        .filter-section {
            margin: 20px 0;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .filter-section label {
            font-weight: bold;
            margin-right: 5px;
        }
        .filter-section select, .filter-section input {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .filter-section button {
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        .filter-section button:hover {
            background-color: #45a049;
        }
        .no-results {
            text-align: center;
            color: #555;
            margin: 20px 0;
        }
        .month-stats .stats-row {
            display: block;
            overflow: hidden; /* Prevent floating issues */
        }
        .month-stats .stats-row p {
            margin: 0 0 10px 0;
        }
        .month-stats .month-outing-table {
            width: 100%; /* Override previous width: 100%; max-width: 600px */
            margin: 20px 0; /* Match the global margin */
        }

        /* Mobile Responsiveness */
        @media screen and (max-width: 600px) {
            body {
                margin: 10px;
                font-size: 14px;
            }
            h1 {
                font-size: 1.5em;
            }
            h2 {
                font-size: 1.2em;
            }
            h3 {
                font-size: 1.1em;
            }
            .stats, .month-stats, .top-outings, .stream-info, .widnr-map-section, .weather-section {
                padding: 10px;
            }
            .widnr-map-section .iframe-container {
                padding-bottom: 75%;
            }
            .filter-section {
                flex-direction: column;
                gap: 10px;
            }
            .filter-section select, .filter-section input {
                width: 100%;
                box-sizing: border-box;
            }
            .filter-section button {
                width: 100%;
            }
            .spots-table, .top-outings-table, .month-outing-table, .weather-table {
                box-shadow: none;
            }
            .spots-table thead, .top-outings-table thead, .month-outing-table thead, .weather-table thead {
                display: none;
            }
            .spots-table tr, .top-outings-table tr, .month-outing-table tr, .weather-table tr {
                display: block;
                margin-bottom: 10px;
                border: 1px solid #ddd;
                border-radius: 5px;
            }
            .spots-table td, .top-outings-table td, .month-outing-table td, .weather-table td {
                display: block;
                text-align: right;
                padding: 8px;
                border: none;
                border-bottom: 1px solid #eee;
                position: relative;
            }
            .spots-table td::before, .top-outings-table td::before, .month-outing-table td::before, .weather-table td::before {
                content: attr(data-label);
                position: absolute;
                left: 8px;
                width: 45%;
                text-align: left;
                font-weight: bold;
                color: #333;
            }
            .spots-table td:last-child, .top-outings-table td:last-child, .month-outing-table td:last-child, .weather-table td:last-child {
                border-bottom: none;
            }
            .spots-table tr:hover, .top-outings-table tr:hover, .month-outing-table tr:hover, .weather-table tr:hover {
                background-color: #fff;
            }
        }
    </style>
</head>
<body>
    <div class="back-link">
        <a href="index.html">← Back to Dashboard</a>
    </div>
    <h1 id="stream-title">Stream Details</h1>
    <div id="loading" class="loading">Loading Stream Details...</div>
    <div id="error" class="error"></div>

    <div id="stream-details" style="display: none;">
        <div class="stream-info">
            <h2>Stream Information</h2>
            <p><strong>Regulation:</strong> <span id="stream-regulation"></span></p>
            <p id="stream-special-regulations-container"><strong>Special Regulations:</strong> <span id="stream-special-regulations"></span></p>
            <p id="stream-gear-restrictions-container"><strong>Gear Restrictions:</strong> <span id="stream-gear-restrictions"></span></p>
            <p><strong>Season Information:</strong> <span id="stream-season-info"></span></p>
            <p><strong>Early Season:</strong> <span id="stream-early-season"></span></p>
            <p id="stream-widnr-link-container"><strong>WIDNR Map:</strong> <span id="stream-widnr-link"></span> | <span id="stream-widnr-external-link"></span></p>
        </div>

        <div class="weather-section">
            <h2>Weather Information</h2>
            <h3>Past 3 Days Weather</h3>
            <table class="weather-table" id="past-weather-table">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Min Temp (°F)</th>
                        <th>Max Temp (°F)</th>
                        <th>Weather Condition</th>
                        <th>Precipitation (in)</th>
                        <th>Recent Rainfall (3 days, in)</th>
                        <th>Wind Speed (mph)</th>
                        <th>Wind Direction</th>
                        <th>Pressure at Noon (hPa)</th>
                        <th>Pressure Trend</th>
                    </tr>
                </thead>
                <tbody id="past-weather-body"></tbody>
            </table>

            <h3>Next 4 Days Weather (Including Today)</h3>
            <table class="weather-table" id="forecast-weather-table">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Min Temp (°F)</th>
                        <th>Max Temp (°F)</th>
                        <th>Weather Condition</th>
                        <th>Precipitation (in)</th>
                        <th>Recent Rainfall (3 days, in)</th>
                        <th>Wind Speed (mph)</th>
                        <th>Wind Direction</th>
                        <th>Pressure at Noon (hPa)</th>
                        <th>Pressure Trend</th>
                    </tr>
                </thead>
                <tbody id="forecast-weather-body"></tbody>
            </table>
        </div>

        <div class="stats">
            <h2>Overall Statistics</h2>
            <p><strong>Total Visits:</strong> <span id="total-visits"></span></p>
            <p><strong>Average Rating:</strong> <span id="avg-rating"></span></p>
            <p><strong>Most Fished Section (Overall):</strong> <span id="most-fished-section"></span></p>
        </div>

        <div class="top-outings">
            <h2>Top 5 Highest Rated Outings</h2>
            <table class="top-outings-table" id="top-outings-table">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Rating</th>
                        <th>Location</th>
                        <th>Section</th>
                        <th>YouTube Link</th>
                    </tr>
                </thead>
                <tbody id="top-outings-body"></tbody>
            </table>
        </div>

        <div class="month-stats">
            <h2>Current Month (April) Statistics</h2>
            <div class="stats-row">
                <p><strong>Typically Fished Section in April:</strong> <span id="april-section"></span></p>
                <table class="month-outing-table" id="month-outing-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Rating</th>
                            <th>Location</th>
                            <th>Section</th>
                            <th>YouTube Link</th>
                        </tr>
                    </thead>
                    <tbody id="month-outing-body"></tbody>
                </table>
            </div>
        </div>

        <h2>Fishing Spots (Downstream to Upstream)</h2>
        <div class="filter-section">
            <div>
                <label for="section-filter">Section:</label>
                <select id="section-filter" onchange="applyFilters()">
                    <option value="All">All</option>
                    <option value="LOWER">LOWER</option>
                    <option value="MIDDLE">MIDDLE</option>
                    <option value="UPPER">UPPER</option>
                    <option value="UNKNOWN">UNKNOWN</option>
                </select>
            </div>
            <div>
                <label for="visits-filter">Min Visits:</label>
                <input type="number" id="visits-filter" min="0" value="" placeholder="e.g., 2" oninput="applyFilters()">
            </div>
            <div>
                <label for="rating-filter">Min Avg Rating:</label>
                <input type="number" id="rating-filter" min="0" max="6" step="0.1" value="" placeholder="e.g., 3.5" oninput="applyFilters()">
            </div>
            <button onclick="clearFilters()">Clear Filters</button>
        </div>
        <div id="no-results" class="no-results" style="display: none;">No spots match the filters.</div>
        <table class="spots-table" id="spots-table">
            <thead>
                <tr>
                    <th onclick="sortSpotsTable(0)">Spot</th>
                    <th onclick="sortSpotsTable(1)">Section</th>
                    <th onclick="sortSpotsTable(2)">Visits</th>
                    <th onclick="sortSpotsTable(3)">Average Rating</th>
                    <th>Google Maps Link</th>
                </tr>
            </thead>
            <tbody id="spots-body"></tbody>
        </table>

        <div class="widnr-map-section" id="widnr-map-section">
            <h2>WIDNR Map</h2>
            <button class="toggle-button" onclick="toggleMap()">Expand Map</button>
            <div id="stream-widnr-iframe" class="iframe-container"></div>
            <div id="stream-widnr-fallback" class="iframe-fallback"></div>
        </div>
    </div>

    <script>
        const SHEET_ID = '1vRDZny6ZfKGXJOKIgoRo47knNJmmtDT2WTrNvOmQ0lwUiznaF1McQVgpTUa1kTMUpq5X6c3b888BGwz';
        const SOURCE_GID = '491893533'; // Rons Spots GPS GID
        const STREAM_INFO_GID = '1772368131'; // Stream Info GID
        const SOURCE_URL = `https://docs.google.com/spreadsheets/d/e/2PACX-${SHEET_ID}/pub?gid=${SOURCE_GID}&single=true&output=csv`;
        const STREAM_INFO_URL = `https://docs.google.com/spreadsheets/d/e/2PACX-${SHEET_ID}/pub?gid=${STREAM_INFO_GID}&single=true&output=csv`;

        let sourceData = null;
        let streamInfoData = null;
        let spotsData = []; // Store all spots for filtering and sorting
        let filteredSpotsData = []; // Store filtered spots for display
        let sortSpotsColumn = 1; // Default sort by Section (to align with downstream-to-upstream)
        let sortSpotsDirection = 1; // 1 for ascending, -1 for descending
        let widnrLink = ''; // Store the WIDNR link for use in the toggle
        let pastWeatherData = [];
        let forecastWeatherData = [];
        let avgLat = null; // Average latitude for forecast
        let avgLon = null; // Average longitude for forecast

        // Define section order for sorting (Lower → Middle → Upper)
        const sectionOrder = { 'LOWER': 1, 'MIDDLE': 2, 'UPPER': 3, 'UNKNOWN': 4 };

        // Get stream name from URL query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const streamName = urlParams.get('stream');

        // Weather code mapping (based on provided script for consistency)
        function getWeatherCondition(code) {
            if (code === null || code === undefined) return 'N/A';
            switch (code) {
                case 0: return 'Sunny';
                case 1: return 'Mostly Sunny';
                case 2: return 'Partly Cloudy';
                case 3: return 'Cloudy';
                case 45: return 'Foggy';
                case 48: return 'Foggy';
                case 51: case 53: case 55: return 'Drizzle';
                case 61: case 63: case 65: return 'Rainy';
                case 66: case 67: return 'Freezing Rain';
                case 71: case 73: case 75: return 'Snow';
                case 77: return 'Snow Grains';
                case 80: case 81: case 82: return 'Rain Showers';
                case 85: case 86: return 'Snow Showers';
                case 95: return 'Thunderstorm';
                case 96: case 99: return 'Thunderstorm with Hail';
                default: return 'Unknown';
            }
        }

        // Convert wind direction (degrees) to cardinal direction
        function degreesToCardinal(degrees) {
            if (degrees === 'N/A' || isNaN(degrees)) return 'N/A';
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round(degrees / 22.5) % 16;
            return directions[index];
        }

        // Initialize page
        async function init() {
            if (!streamName) {
                document.getElementById('error').textContent = 'Error: No stream specified.';
                document.getElementById('loading').style.display = 'none';
                return;
            }

            document.getElementById('stream-title').textContent = `${streamName} Details`;
            await Promise.all([fetchData(), fetchStreamInfo()]);
            calculateAverageCoordinates();
            await fetchWeatherData();
            displayStreamDetails();
            displayWeatherData();
        }

        // Calculate average coordinates for forecast
        function calculateAverageCoordinates() {
            if (!sourceData || !sourceData.rows) return;
            const validSpots = sourceData.rows
                .filter(row => row[2]?.trim() === streamName && !isNaN(parseFloat(row[12])) && !isNaN(parseFloat(row[13])))
                .map(row => ({
                    lat: parseFloat(row[12]),
                    lon: parseFloat(row[13])
                }));
            if (validSpots.length === 0) return;
            avgLat = validSpots.reduce((sum, spot) => sum + spot.lat, 0) / validSpots.length;
            avgLon = validSpots.reduce((sum, spot) => sum + spot.lon, 0) / validSpots.length;
        }

        // Fetch fishing spots data
        async function fetchData() {
            try {
                const response = await fetch(SOURCE_URL);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const csvText = await response.text();
                if (!csvText.trim()) throw new Error('Empty CSV data');
                sourceData = parseCSV(csvText);
            } catch (error) {
                document.getElementById('error').textContent = `Error fetching spots data: ${error.message}`;
            }
        }

        // Fetch stream info data
        async function fetchStreamInfo() {
            try {
                const response = await fetch(STREAM_INFO_URL);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const csvText = await response.text();
                if (!csvText.trim()) throw new Error('Empty stream info CSV data');
                streamInfoData = parseCSV(csvText);
            } catch (error) {
                document.getElementById('error').textContent = `Error fetching stream info: ${error.message}`;
            }
        }

        // Fetch weather data
        async function fetchWeatherData() {
            if (!sourceData || !sourceData.rows) {
                document.getElementById('past-weather-body').innerHTML = '<tr><td colspan="10" data-label="Result">No stream data available.</td></tr>';
                document.getElementById('forecast-weather-body').innerHTML = '<tr><td colspan="10" data-label="Result">No stream data available.</td></tr>';
                return;
            }

            // Past weather: Fetch for unique date-GPS pairs from outings
            const dateGPSMap = new Map();
            const streamData = sourceData.rows
                .filter(row => row[2]?.trim() === streamName && row.length >= 18)
                .map(row => ({
                    dateStr: new Date(row[0].replace(/(\d+)\/(\d+)\/(\d+)/, '$3-$1-$2')).toISOString().split('T')[0],
                    lat: parseFloat(row[12]),
                    lon: parseFloat(row[13])
                }))
                .filter(entry => !isNaN(entry.lat) && !isNaN(entry.lon));

            streamData.forEach(entry => {
                const key = `${entry.dateStr}|${entry.lat.toFixed(5)}|${entry.lon.toFixed(5)}`;
                dateGPSMap.set(key, { date: entry.dateStr, lat: entry.lat, lon: entry.lon });
            });

            const dateGPSPairs = Array.from(dateGPSMap.values());

            for (const { date, lat, lon } of dateGPSPairs) {
                try {
                    const startDate = new Date(date);
                    startDate.setDate(startDate.getDate() - 2);
                    const startDateStr = startDate.toISOString().split('T')[0];
                    const response = await fetch(
                        `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${startDateStr}&end_date=${date}&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,wind_speed_10m_max,weather_code&hourly=pressure_msl,wind_direction_10m&timezone=auto&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch`
                    );
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();

                    const noonIndex = data.hourly.time.findIndex(t => t.includes(`${date}T12:00`));
                    const pressure = noonIndex !== -1 ? Math.round(data.hourly.pressure_msl[noonIndex]) : 'N/A';
                    const wind_direction = noonIndex !== -1 ? data.hourly.wind_direction_10m[noonIndex] : 'N/A';

                    const dayIndex = data.daily.time.findIndex(t => t === date);
                    const temp_max = dayIndex !== -1 ? data.daily.temperature_2m_max[dayIndex].toFixed(1) : 'N/A';
                    const temp_min = dayIndex !== -1 ? data.daily.temperature_2m_min[dayIndex].toFixed(1) : 'N/A';
                    const precipitation = dayIndex !== -1 ? parseFloat(data.daily.precipitation_sum[dayIndex]).toFixed(2) : 'N/A';
                    const wind_speed = dayIndex !== -1 ? data.daily.wind_speed_10m_max[dayIndex].toFixed(1) : 'N/A';
                    const weather_code = dayIndex !== -1 ? data.daily.weather_code[dayIndex] : 'N/A';
                    const recent_rainfall = data.daily.precipitation_sum.reduce((sum, val) => sum + (val || 0), 0).toFixed(2);

                    let pressureTrend = 'N/A';
                    if (pressure !== 'N/A') {
                        const dayBefore = new Date(date);
                        dayBefore.setDate(dayBefore.getDate() - 1);
                        const dayAfter = new Date(date);
                        dayAfter.setDate(dayAfter.getDate() + 1);
                        const rangeStart = dayBefore.toISOString().split('T')[0];
                        const rangeEnd = dayAfter.toISOString().split('T')[0];

                        const trendResponse = await fetch(
                            `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${rangeStart}&end_date=${rangeEnd}&hourly=pressure_msl&timezone=auto`
                        );
                        if (trendResponse.ok) {
                            const trendData = await trendResponse.json();
                            const times = trendData.hourly.time;
                            const pressures = trendData.hourly.pressure_msl;

                            const prevNoon = times.findIndex(t => t.includes(`${rangeStart}T12:00`));
                            const currNoon = times.findIndex(t => t.includes(`${date}T12:00`));
                            const nextNoon = times.findIndex(t => t.includes(`${rangeEnd}T12:00`));

                            if (prevNoon !== -1 && currNoon !== -1 && nextNoon !== -1) {
                                const prevPressure = pressures[prevNoon];
                                const currPressure = pressures[currNoon];
                                const nextPressure = pressures[nextNoon];
                                const MIN_CHANGE = 1.0;
                                const SIGNIFICANT_CHANGE = 5.0;

                                const change = currPressure - prevPressure;
                                if (change > SIGNIFICANT_CHANGE && currPressure <= nextPressure) {
                                    pressureTrend = 'Significant Rising';
                                } else if (change > MIN_CHANGE && currPressure <= nextPressure) {
                                    pressureTrend = 'Rising';
                                } else if (change < -SIGNIFICANT_CHANGE && currPressure >= nextPressure) {
                                    pressureTrend = 'Significant Falling';
                                } else if (change < -MIN_CHANGE && currPressure >= nextPressure) {
                                    pressureTrend = 'Falling';
                                } else {
                                    pressureTrend = 'Stable';
                                }
                            }
                        }
                    }

                    pastWeatherData.push({
                        date,
                        lat,
                        lon,
                        temp_max,
                        temp_min,
                        precipitation,
                        recent_rainfall,
                        wind_speed,
                        wind_direction,
                        pressure,
                        pressure_trend: pressureTrend,
                        weather_code
                    });
                } catch (error) {
                    pastWeatherData.push({
                        date,
                        lat,
                        lon,
                        temp_max: 'N/A',
                        temp_min: 'N/A',
                        precipitation: 'N/A',
                        recent_rainfall: 'N/A',
                        wind_speed: 'N/A',
                        wind_direction: 'N/A',
                        pressure: 'N/A',
                        pressure_trend: 'N/A',
                        weather_code: 'N/A'
                    });
                }
            }

            // Forecast weather: Fetch for average coordinates
            if (avgLat && avgLon) {
                try {
                    const response = await fetch(
                        `https://api.open-meteo.com/v1/forecast?latitude=${avgLat}&longitude=${avgLon}&daily=temperature_2m_max,temperature_2m_min,precipitation_sum,wind_speed_10m_max,weather_code&hourly=pressure_msl,wind_direction_10m&forecast_days=4&timezone=auto&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch`
                    );
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    const data = await response.json();

                    forecastWeatherData = data.daily.time.map((date, index) => {
                        const noonIndex = data.hourly.time.findIndex(t => t.includes(`${date}T12:00`));
                        const pressure = noonIndex !== -1 ? Math.round(data.hourly.pressure_msl[noonIndex]) : 'N/A';
                        const wind_direction = noonIndex !== -1 ? data.hourly.wind_direction_10m[noonIndex] : 'N/A';

                        const temp_max = data.daily.temperature_2m_max[index].toFixed(1);
                        const temp_min = data.daily.temperature_2m_min[index].toFixed(1);
                        const precipitation = parseFloat(data.daily.precipitation_sum[index]).toFixed(2);
                        const wind_speed = data.daily.wind_speed_10m_max[index].toFixed(1);
                        const weather_code = data.daily.weather_code[index];

                        // Recent rainfall: Use historical data up to today, note for future
                        let recent_rainfall = 'N/A';
                        const today = new Date().toISOString().split('T')[0];
                        if (date <= today) {
                            const startDate = new Date(date);
                            startDate.setDate(startDate.getDate() - 2);
                            const startDateStr = startDate.toISOString().split('T')[0];
                            // Note: This requires an additional API call, omitted for simplicity
                            recent_rainfall = 'See Past Weather';
                        }

                        let pressureTrend = 'N/A';
                        if (pressure !== 'N/A' && index > 0) {
                            const prevNoon = data.hourly.time.findIndex(t => t.includes(`${data.daily.time[index - 1]}T12:00`));
                            if (prevNoon !== -1) {
                                const prevPressure = data.hourly.pressure_msl[prevNoon];
                                const currPressure = data.hourly.pressure_msl[noonIndex];
                                const MIN_CHANGE = 1.0;
                                const SIGNIFICANT_CHANGE = 5.0;
                                const change = currPressure - prevPressure;
                                if (change > SIGNIFICANT_CHANGE) {
                                    pressureTrend = 'Significant Rising';
                                } else if (change > MIN_CHANGE) {
                                    pressureTrend = 'Rising';
                                } else if (change < -SIGNIFICANT_CHANGE) {
                                    pressureTrend = 'Significant Falling';
                                } else if (change < -MIN_CHANGE) {
                                    pressureTrend = 'Falling';
                                } else {
                                    pressureTrend = 'Stable';
                                }
                            }
                        }

                        return {
                            date,
                            lat: avgLat,
                            lon: avgLon,
                            temp_max,
                            temp_min,
                            precipitation,
                            recent_rainfall,
                            wind_speed,
                            wind_direction,
                            pressure,
                            pressure_trend: pressureTrend,
                            weather_code
                        };
                    });
                } catch (error) {
                    forecastWeatherData = Array(4).fill().map((_, i) => ({
                        date: new Date(Date.now() + i * 86400000).toISOString().split('T')[0],
                        lat: avgLat,
                        lon: avgLon,
                        temp_max: 'N/A',
                        temp_min: 'N/A',
                        precipitation: 'N/A',
                        recent_rainfall: 'N/A',
                        wind_speed: 'N/A',
                        wind_direction: 'N/A',
                        pressure: 'N/A',
                        pressure_trend: 'N/A',
                        weather_code: 'N/A'
                    }));
                }
            } else {
                forecastWeatherData = Array(4).fill().map((_, i) => ({
                    date: new Date(Date.now() + i * 86400000).toISOString().split('T')[0],
                    lat: null,
                    lon: null,
                    temp_max: 'N/A',
                    temp_min: 'N/A',
                    precipitation: 'N/A',
                    recent_rainfall: 'N/A',
                    wind_speed: 'N/A',
                    wind_direction: 'N/A',
                    pressure: 'N/A',
                    pressure_trend: 'N/A',
                    weather_code: 'N/A'
                }));
            }
        }

        // Display weather data
        function displayWeatherData() {
            const pastWeatherBody = document.getElementById('past-weather-body');
            pastWeatherBody.innerHTML = '';
            const uniqueDates = [...new Set(pastWeatherData.map(w => w.date))].sort().slice(-3); // Last 3 unique dates
            uniqueDates.forEach(date => {
                const weatherEntries = pastWeatherData.filter(w => w.date === date);
                const weather = weatherEntries[0] || {
                    temp_max: 'N/A',
                    temp_min: 'N/A',
                    precipitation: 'N/A',
                    recent_rainfall: 'N/A',
                    wind_speed: 'N/A',
                    wind_direction: 'N/A',
                    pressure: 'N/A',
                    pressure_trend: 'N/A',
                    weather_code: 'N/A'
                };
                const tr = document.createElement('tr');
                const formattedDate = new Date(date).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                tr.innerHTML = `
                    <td data-label="Date">${formattedDate}</td>
                    <td data-label="Min Temp (°F)">${weather.temp_max}</td>
                    <td data-label="Max Temp (°F)">${weather.temp_min}</td>
                    <td data-label="Weather Condition">${getWeatherCondition(weather.weather_code)}</td>
                    <td data-label="Precipitation (in)">${weather.precipitation}</td>
                    <td data-label="Recent Rainfall (3 days, in)">${weather.recent_rainfall}</td>
                    <td data-label="Wind Speed (mph)">${weather.wind_speed}</td>
                    <td data-label="Wind Direction">${degreesToCardinal(weather.wind_direction)}</td>
                    <td data-label="Pressure at Noon (hPa)">${weather.pressure}</td>
                    <td data-label="Pressure Trend">${weather.pressure_trend}</td>
                `;
                pastWeatherBody.appendChild(tr);
            });
            if (uniqueDates.length === 0) {
                pastWeatherBody.innerHTML = '<tr><td colspan="10" data-label="Result">No past weather data available.</td></tr>';
            }

            const forecastWeatherBody = document.getElementById('forecast-weather-body');
            forecastWeatherBody.innerHTML = '';
            forecastWeatherData.forEach(weather => {
                const tr = document.createElement('tr');
                const formattedDate = new Date(weather.date).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                tr.innerHTML = `
                    <td data-label="Date">${formattedDate}</td>
                    <td data-label="Min Temp (°F)">${weather.temp_max}</td>
                    <td data-label="Max Temp (°F)">${weather.temp_min}</td>
                    <td data-label="Weather Condition">${getWeatherCondition(weather.weather_code)}</td>
                    <td data-label="Precipitation (in)">${weather.precipitation}</td>
                    <td data-label="Recent Rainfall (3 days, in)">${weather.recent_rainfall}</td>
                    <td data-label="Wind Speed (mph)">${weather.wind_speed}</td>
                    <td data-label="Wind Direction">${degreesToCardinal(weather.wind_direction)}</td>
                    <td data-label="Pressure at Noon (hPa)">${weather.pressure}</td>
                    <td data-label="Pressure Trend">${weather.pressure_trend}</td>
                `;
                forecastWeatherBody.appendChild(tr);
            });
        }

        // Parse CSV
        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            const headers = lines[0].split(',').map(header => header.trim());
            const rows = lines.slice(1).map(line => {
                const values = [];
                let current = '';
                let insideQuotes = false;
                for (let char of line) {
                    if (char === '"') {
                        insideQuotes = !insideQuotes;
                    } else if (char === ',' && !insideQuotes) {
                        values.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim());
                return values;
            });
            return { headers, rows };
        }

        // Toggle the WIDNR map visibility
        function toggleMap() {
            const iframeContainer = document.getElementById('stream-widnr-iframe');
            const fallback = document.getElementById('stream-widnr-fallback');
            const toggleButton = document.querySelector('.toggle-button');
            const isExpanded = iframeContainer.classList.contains('active');

            if (isExpanded) {
                iframeContainer.classList.remove('active');
                fallback.classList.remove('active');
                toggleButton.textContent = 'Expand Map';
            } else {
                iframeContainer.classList.add('active');
                fallback.classList.add('active');
                toggleButton.textContent = 'Collapse Map';
            }
        }

        // Apply filters to the spots data
        function applyFilters() {
            const sectionFilter = document.getElementById('section-filter').value;
            const visitsFilter = document.getElementById('visits-filter').value;
            const ratingFilter = document.getElementById('rating-filter').value;

            filteredSpotsData = spotsData.filter(spot => {
                if (sectionFilter !== 'All' && spot.section !== sectionFilter) {
                    return false;
                }
                if (visitsFilter !== '' && spot.visits < parseInt(visitsFilter)) {
                    return false;
                }
                if (ratingFilter !== '' && (spot.avgRating === 'N/A' || spot.avgRating < parseFloat(ratingFilter))) {
                    return false;
                }
                return true;
            });

            sortFilteredSpots();
        }

        // Clear all filters
        function clearFilters() {
            document.getElementById('section-filter').value = 'All';
            document.getElementById('visits-filter').value = '';
            document.getElementById('rating-filter').value = '';
            filteredSpotsData = [...spotsData];
            sortFilteredSpots();
        }

        // Sort the filtered spots table
        function sortSpotsTable(colIndex) {
            if (sortSpotsColumn === colIndex) {
                sortSpotsDirection = -sortSpotsDirection;
            } else {
                sortSpotsColumn = colIndex;
                sortSpotsDirection = 1;
            }

            const headers = document.querySelectorAll('.spots-table th');
            headers.forEach((th, index) => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (index === colIndex) {
                    th.classList.add(sortSpotsDirection === 1 ? 'sort-asc' : 'sort-desc');
                }
            });

            sortFilteredSpots();
        }

        // Sort and render the filtered spots
        function sortFilteredSpots() {
            filteredSpotsData.sort((a, b) => {
                let valueA, valueB;
                if (sortSpotsColumn === 0) { // Spot (numeric)
                    valueA = a.index;
                    valueB = b.index;
                    return sortSpotsDirection * (valueA - valueB);
                } else if (sortSpotsColumn === 1) { // Section (custom order: Lower → Middle → Upper)
                    valueA = sectionOrder[a.section] || 5;
                    valueB = sectionOrder[b.section] || 5;
                    return sortSpotsDirection * (valueA - valueB);
                } else if (sortSpotsColumn === 2) { // Visits (numeric)
                    valueA = a.visits;
                    valueB = b.visits;
                    return sortSpotsDirection * (valueA - valueB);
                } else if (sortSpotsColumn === 3) { // Average Rating (numeric, handle N/A)
                    valueA = a.avgRating !== 'N/A' ? a.avgRating : -1;
                    valueB = b.avgRating !== 'N/A' ? b.avgRating : -1;
                    return sortSpotsDirection * (valueA - valueB);
                }
                return 0;
            });

            filteredSpotsData.forEach((spot, idx) => {
                spot.index = idx + 1;
            });

            const spotsBody = document.getElementById('spots-body');
            const noResultsDiv = document.getElementById('no-results');
            spotsBody.innerHTML = '';
            if (filteredSpotsData.length === 0) {
                noResultsDiv.style.display = 'block';
            } else {
                noResultsDiv.style.display = 'none';
                filteredSpotsData.forEach(spot => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `
                        <td data-label="Spot">Spot ${spot.index}</td>
                        <td data-label="Section">${spot.section}</td>
                        <td data-label="Visits">${spot.visits}</td>
                        <td data-label="Average Rating">${spot.avgRating}</td>
                        <td data-label="Google Maps Link"><a href="https://www.google.com/maps?q=${spot.lat},${spot.lon}" target="_blank">View on Google Maps</a></td>
                    `;
                    spotsBody.appendChild(tr);
                });
            }
        }

        // Display stream details
        function displayStreamDetails() {
            const ratingMap = { 'E': 0, 'D': 1, 'C': 2, 'B': 3, 'A': 4, 'S': 5, 'S+': 6 };
            const ratingReverseMap = { 0: 'E', 1: 'D', 2: 'C', 3: 'B', 4: 'A', 5: 'S', 6: 'S+' };
            const excludedStreams = ['Unknown', 'Central Sands', 'Minnesota', 'Southern WI'];

            const streamData = sourceData?.rows
                .filter(row => {
                    if (row.length < 18) return false;
                    const date = new Date(row[0].replace(/(\d+)\/(\d+)\/(\d+)/, '$3-$1-$2'));
                    const stream = row[2]?.trim() || '';
                    const rating = row[17]?.toUpperCase();
                    const validRating = /^[SABCDE]|S+$/.test(rating);
                    const validStream = !excludedStreams.some(excluded => stream.includes(excluded));
                    return stream === streamName && validRating && validStream && !isNaN(date.getTime());
                })
                .map(row => {
                    const date = new Date(row[0].replace(/(\d+)\/(\d+)\/(\d+)/, '$3-$1-$2'));
                    const month = date.toLocaleString('default', { month: 'long' });
                    const stream = row[2]?.trim() || '';
                    const rating = ratingMap[row[17]?.toUpperCase()] ?? -1;
                    const section = row[15]?.trim().toUpperCase() || 'UNKNOWN';
                    const lat = parseFloat(row[12]);
                    const lon = parseFloat(row[13]);
                    const youtubeLink = row[1]?.trim() || '';
                    return { month, stream, rating, section, lat, lon, date, youtubeLink };
                }) || [];

            if (streamData.length === 0) {
                document.getElementById('error').textContent = 'No data found for this stream.';
                return;
            }

            if (streamInfoData) {
                const streamInfoRow = streamInfoData.rows.find(row => row[0]?.trim() === streamName);
                if (streamInfoRow) {
                    document.getElementById('stream-regulation').textContent = streamInfoRow[1] || 'N/A';
                    const specialRegulations = streamInfoRow[2] || 'None';
                    const specialRegulationsContainer = document.getElementById('stream-special-regulations-container');
                    if (specialRegulations.toUpperCase() === 'N/A') {
                        specialRegulationsContainer.style.display = 'none';
                    } else {
                        document.getElementById('stream-special-regulations').textContent = specialRegulations;
                        specialRegulationsContainer.style.display = 'block';
                    }
                    const gearRestrictions = streamInfoRow[3] || 'N/A';
                    const gearRestrictionsContainer = document.getElementById('stream-gear-restrictions-container');
                    if (gearRestrictions.toUpperCase() === 'N/A') {
                        gearRestrictionsContainer.style.display = 'none';
                    } else {
                        document.getElementById('stream-gear-restrictions').textContent = gearRestrictions;
                        gearRestrictionsContainer.style.display = 'block';
                    }
                    document.getElementById('stream-season-info').textContent = streamInfoRow[4] || 'N/A';
                    document.getElementById('stream-early-season').textContent = streamInfoRow[5] || 'N/A';
                    widnrLink = streamInfoRow[6]?.trim();
                    const widnrLinkContainer = document.getElementById('stream-widnr-link-container');
                    if (widnrLink) {
                        document.getElementById('stream-widnr-link').innerHTML = `<a href="#widnr-map-section" onclick="toggleMap()">View WIDNR Map</a>`;
                        document.getElementById('stream-widnr-external-link').innerHTML = `<a href="${widnrLink}" target="_blank">View WIDNR Map External Link</a>`;
                        widnrLinkContainer.style.display = 'block';
                        document.getElementById('stream-widnr-iframe').innerHTML = `<iframe src="${widnrLink}" loading="lazy" allowfullscreen></iframe>`;
                        document.getElementById('stream-widnr-fallback').innerHTML = `If the map doesn't load, <a href="${widnrLink}" target="_blank">view WIDNR details here</a>.`;
                    } else {
                        widnrLinkContainer.style.display = 'none';
                        document.getElementById('stream-widnr-iframe').innerHTML = '';
                        document.getElementById('stream-widnr-fallback').textContent = 'N/A';
                    }
                } else {
                    document.getElementById('stream-regulation').textContent = 'N/A';
                    document.getElementById('stream-special-regulations-container').style.display = 'none';
                    document.getElementById('stream-gear-restrictions-container').style.display = 'none';
                    document.getElementById('stream-season-info').textContent = 'N/A';
                    document.getElementById('stream-early-season').textContent = 'N/A';
                    document.getElementById('stream-widnr-link-container').style.display = 'none';
                    document.getElementById('stream-widnr-iframe').innerHTML = '';
                    document.getElementById('stream-widnr-fallback').textContent = 'N/A';
                }
            } else {
                document.getElementById('stream-regulation').textContent = 'Error loading data';
                document.getElementById('stream-special-regulations-container').style.display = 'none';
                document.getElementById('stream-gear-restrictions-container').style.display = 'none';
                document.getElementById('stream-season-info').textContent = 'Error loading data';
                document.getElementById('stream-early-season').textContent = 'Error loading data';
                document.getElementById('stream-widnr-link-container').style.display = 'none';
                document.getElementById('stream-widnr-iframe').innerHTML = '';
                document.getElementById('stream-widnr-fallback').textContent = 'Error loading data';
            }

            const totalVisits = streamData.length;
            const avgRating = streamData.reduce((sum, entry) => sum + entry.rating, 0) / totalVisits;
            const roundedAvg = Math.round(avgRating * 100) / 100;

            const sectionCounts = { LOWER: 0, MIDDLE: 0, UPPER: 0 };
            streamData.forEach(entry => {
                if (entry.section in sectionCounts) sectionCounts[entry.section]++;
                else sectionCounts['UNKNOWN'] = (sectionCounts['UNKNOWN'] || 0) + 1;
            });
            const maxCount = Math.max(sectionCounts.LOWER, sectionCounts.MIDDLE, sectionCounts.UPPER);
            const tieCheck = (sectionCounts.LOWER === maxCount ? 1 : 0) +
                             (sectionCounts.MIDDLE === maxCount ? 1 : 0) +
                             (sectionCounts.UPPER === maxCount ? 1 : 0);
            let mostFishedSection = 'Mixed';
            if (maxCount > 0 && tieCheck === 1) {
                if (sectionCounts.LOWER === maxCount) mostFishedSection = 'Lower';
                else if (sectionCounts.MIDDLE === maxCount) mostFishedSection = 'Middle';
                else if (sectionCounts.UPPER === maxCount) mostFishedSection = 'Upper';
            }

            const aprilData = streamData.filter(entry => entry.month === 'April');
            const aprilSectionCounts = { LOWER: 0, MIDDLE: 0, UPPER: 0 };
            aprilData.forEach(entry => {
                if (entry.section in aprilSectionCounts) aprilSectionCounts[entry.section]++;
                else aprilSectionCounts['UNKNOWN'] = (aprilSectionCounts['UNKNOWN'] || 0) + 1;
            });
            const aprilMaxCount = Math.max(aprilSectionCounts.LOWER, aprilSectionCounts.MIDDLE, aprilSectionCounts.UPPER);
            const aprilTieCheck = (aprilSectionCounts.LOWER === aprilMaxCount ? 1 : 0) +
                                  (aprilSectionCounts.MIDDLE === aprilMaxCount ? 1 : 0) +
                                  (aprilSectionCounts.UPPER === aprilMaxCount ? 1 : 0);
            let aprilSection = aprilData.length > 0 ? 'Mixed' : 'No April data';
            if (aprilMaxCount > 0 && aprilTieCheck === 1) {
                if (aprilSectionCounts.LOWER === aprilMaxCount) aprilSection = 'Lower';
                else if (aprilSectionCounts.MIDDLE === aprilMaxCount) aprilSection = 'Middle';
                else if (aprilSectionCounts.UPPER === aprilMaxCount) aprilSection = 'Upper';
            }

            const bestAprilOuting = aprilData.length > 0 ? aprilData.reduce((best, current) => best.rating > current.rating ? best : current) : null;
            const monthOutingBody = document.getElementById('month-outing-body');
            monthOutingBody.innerHTML = '';
            if (bestAprilOuting) {
                const formattedDate = bestAprilOuting.date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                const ratingLetter = ratingReverseMap[bestAprilOuting.rating] || 'N/A';
                const youtubeLink = bestAprilOuting.youtubeLink ? `<a href="${bestAprilOuting.youtubeLink}" target="_blank">Watch on YouTube</a>` : 'N/A';
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td data-label="Date">${formattedDate}</td>
                    <td data-label="Rating">${ratingLetter}</td>
                    <td data-label="Location"><a href="https://www.google.com/maps?q=${bestAprilOuting.lat},${bestAprilOuting.lon}" target="_blank">View on Google Maps</a></td>
                    <td data-label="Section">${bestAprilOuting.section}</td>
                    <td data-label="YouTube Link">${youtubeLink}</td>
                `;
                monthOutingBody.appendChild(tr);
            } else {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="5" data-label="Result">No April outings found.</td>`;
                monthOutingBody.appendChild(tr);
            }

            document.getElementById('total-visits').textContent = totalVisits;
            document.getElementById('avg-rating').textContent = roundedAvg;
            document.getElementById('most-fished-section').textContent = mostFishedSection;
            document.getElementById('april-section').textContent = aprilSection;

            const sortedOutings = streamData.sort((a, b) => b.rating - a.rating).slice(0, 5);
            const topOutingsBody = document.getElementById('top-outings-body');
            topOutingsBody.innerHTML = '';
            sortedOutings.forEach(outing => {
                const tr = document.createElement('tr');
                const formattedDate = outing.date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                const ratingLetter = ratingReverseMap[outing.rating] || 'N/A';
                const youtubeLink = outing.youtubeLink ? `<a href="${outing.youtubeLink}" target="_blank">Watch on YouTube</a>` : 'N/A';
                tr.innerHTML = `
                    <td data-label="Date">${formattedDate}</td>
                    <td data-label="Rating">${ratingLetter}</td>
                    <td data-label="Location"><a href="https://www.google.com/maps?q=${outing.lat},${outing.lon}" target="_blank">View on Google Maps</a></td>
                    <td data-label="Section">${outing.section}</td>
                    <td data-label="YouTube Link">${youtubeLink}</td>
                `;
                topOutingsBody.appendChild(tr);
            });

            const spotsMap = new Map();
            streamData.forEach((entry, index) => {
                if (!isNaN(entry.lat) && !isNaN(entry.lon)) {
                    const lat = Number(entry.lat.toFixed(5));
                    const lon = Number(entry.lon.toFixed(5));
                    const key = `${lat},${lon}`;
                    if (!spotsMap.has(key)) {
                        spotsMap.set(key, { lat, lon, sections: [entry.section], visits: 1, ratings: [entry.rating] });
                    } else {
                        const spot = spotsMap.get(key);
                        spot.sections.push(entry.section);
                        spot.visits += 1;
                        spot.ratings.push(entry.rating);
                    }
                }
            });

            spotsData = Array.from(spotsMap.values()).map(spot => {
                const sectionCounts = { LOWER: 0, MIDDLE: 0, UPPER: 0, UNKNOWN: 0 };
                spot.sections.forEach(section => {
                    sectionCounts[section] = (sectionCounts[section] || 0) + 1;
                });
                let maxCount = 0;
                let selectedSection = 'UNKNOWN';
                for (const [section, count] of Object.entries(sectionCounts)) {
                    if (count > maxCount) {
                        maxCount = count;
                        selectedSection = section;
                    } else if (count === maxCount) {
                        const order = sectionOrder[section] || 5;
                        const currentOrder = sectionOrder[selectedSection] || 5;
                        if (order < currentOrder) {
                            selectedSection = section;
                        }
                    }
                }
                const validRatings = spot.ratings.filter(r => r >= 0);
                const avgRating = validRatings.length > 0
                    ? Math.round((validRatings.reduce((sum, r) => sum + r, 0) / validRatings.length) * 100) / 100
                    : 'N/A';
                return { lat: spot.lat, lon: spot.lon, section: selectedSection, visits: spot.visits, avgRating };
            });

            spotsData.sort((a, b) => {
                const sectionA = sectionOrder[a.section] || 5;
                const sectionB = sectionOrder[b.section] || 5;
                return sectionA - sectionB;
            });

            spotsData.forEach((spot, idx) => {
                spot.index = idx + 1;
            });

            filteredSpotsData = [...spotsData];
            sortFilteredSpots();

            document.getElementById('stream-details').style.display = 'block';
            document.getElementById('loading').style.display = 'none';
        }

        // Initialize
        init();
    </script>
</body>
</html>
