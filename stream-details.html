<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Details</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f9; }
        h1, h2 { color: #333; }
        .back-link { margin-bottom: 20px; }
        a { color: #4CAF50; text-decoration: none; }
        a:hover { text-decoration: underline; }
        .stats, .month-stats { margin: 20px 0; padding: 15px; background-color: #fff; border-radius: 5px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        .spots-table { width: 100%; max-width: 800px; margin: 20px 0; border-collapse: collapse; background-color: #fff; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }
        .spots-table th, .spots-table td { padding: 12px; text-align: left; border: 1px solid #ddd; }
        .spots-table th { background-color: #4CAF50; color: white; cursor: pointer; }
        .spots-table th:hover { background-color: #45a049; }
        .spots-table th.sort-asc::after { content: ' ↑'; }
        .spots-table th.sort-desc::after { content: ' ↓'; }
        .spots-table tr:nth-child(even) { background-color: #f9f9f9; }
        .spots-table tr:hover { background-color: #f1f1f1; }
        .loading { text-align: center; font-size: 1.2em; color: #555; }
        .error { text-align: center; color: red; }
    </style>
</head>
<body>
    <div class="back-link">
        <a href="index.html">← Back to Dashboard</a>
    </div>
    <h1 id="stream-title">Stream Details</h1>
    <div id="loading" class="loading">Loading Stream Details...</div>
    <div id="error" class="error"></div>

    <div id="stream-details" style="display: none;">
        <div class="stats">
            <h2>Overall Statistics</h2>
            <p><strong>Total Visits:</strong> <span id="total-visits"></span></p>
            <p><strong>Average Rating:</strong> <span id="avg-rating"></span></p>
            <p><strong>Most Fished Section (Overall):</strong> <span id="most-fished-section"></span></p>
        </div>

        <div class="month-stats">
            <h2>Current Month (April) Statistics</h2>
            <p><strong>Typically Fished Section in April:</strong> <span id="april-section"></span></p>
        </div>

        <h2>Fishing Spots (Downstream to Upstream)</h2>
        <table class="spots-table" id="spots-table">
            <thead>
                <tr>
                    <th onclick="sortSpotsTable(0)">Spot</th>
                    <th onclick="sortSpotsTable(1)">Latitude</th>
                    <th onclick="sortSpotsTable(2)">Longitude</th>
                    <th onclick="sortSpotsTable(3)">Section</th>
                    <th>Google Maps Link</th>
                </tr>
            </thead>
            <tbody id="spots-body"></tbody>
        </table>
    </div>

    <script>
        const SHEET_ID = '1vRDZny6ZfKGXJOKIgoRo47knNJmmtDT2WTrNvOmQ0lwUiznaF1McQVgpTUa1kTMUpq5X6c3b888BGwz';
        const SOURCE_GID = '491893533'; // Rons Spots GPS GID
        const SOURCE_URL = `https://docs.google.com/spreadsheets/d/e/2PACX-${SHEET_ID}/pub?gid=${SOURCE_GID}&single=true&output=csv`;

        let sourceData = null;
        let spotsData = []; // Store spots for sorting
        let sortSpotsColumn = 3; // Default sort by Section (to align with downstream-to-upstream)
        let sortSpotsDirection = 1; // 1 for ascending, -1 for descending

        // Define section order for sorting (Lower → Middle → Upper)
        const sectionOrder = { 'LOWER': 1, 'MIDDLE': 2, 'UPPER': 3, 'UNKNOWN': 4 };

        // Get stream name from URL query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const streamName = urlParams.get('stream');

        // Initialize page
        function init() {
            if (!streamName) {
                document.getElementById('error').textContent = 'Error: No stream specified.';
                document.getElementById('loading').style.display = 'none';
                return;
            }

            document.getElementById('stream-title').textContent = `${streamName} Details`;
            fetchData();
        }

        // Fetch and process data
        async function fetchData() {
            try {
                const response = await fetch(SOURCE_URL);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const csvText = await response.text();
                if (!csvText.trim()) throw new Error('Empty CSV data');
                sourceData = parseCSV(csvText);
                displayStreamDetails();
            } catch (error) {
                document.getElementById('error').textContent = `Error: ${error.message}`;
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Parse CSV
        function parseCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim() !== '');
            const headers = lines[0].split(',').map(header => header.trim());
            const rows = lines.slice(1).map(line => {
                const values = [];
                let current = '';
                let insideQuotes = false;
                for (let char of line) {
                    if (char === '"') {
                        insideQuotes = !insideQuotes;
                    } else if (char === ',' && !insideQuotes) {
                        values.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                values.push(current.trim());
                return values;
            });
            return { headers, rows };
        }

        // Sort the spots table
        function sortSpotsTable(colIndex) {
            if (sortSpotsColumn === colIndex) {
                sortSpotsDirection = -sortSpotsDirection;
            } else {
                sortSpotsColumn = colIndex;
                sortSpotsDirection = 1;
            }

            // Update sort indicators
            const headers = document.querySelectorAll('.spots-table th');
            headers.forEach((th, index) => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (index === colIndex) {
                    th.classList.add(sortSpotsDirection === 1 ? 'sort-asc' : 'sort-desc');
                }
            });

            spotsData.sort((a, b) => {
                let valueA, valueB;
                if (colIndex === 0) { // Spot (numeric)
                    valueA = a.index;
                    valueB = b.index;
                    return sortSpotsDirection * (valueA - valueB);
                } else if (colIndex === 1 || colIndex === 2) { // Latitude or Longitude (numeric)
                    valueA = colIndex === 1 ? a.lat : a.lon;
                    valueB = colIndex === 1 ? b.lat : b.lon;
                    return sortSpotsDirection * (valueA - valueB);
                } else if (colIndex === 3) { // Section (custom order: Lower → Middle → Upper)
                    valueA = sectionOrder[a.section] || 5;
                    valueB = sectionOrder[b.section] || 5;
                    if (valueA === valueB) {
                        // Within the same section, sort by latitude
                        return (a.lat - b.lat) * sortSpotsDirection;
                    }
                    return sortSpotsDirection * (valueA - valueB);
                }
                return 0;
            });

            // Reassign Spot numbers based on the new sorted order
            spotsData.forEach((spot, idx) => {
                spot.index = idx + 1;
            });

            // Re-render the table body
            const spotsBody = document.getElementById('spots-body');
            spotsBody.innerHTML = '';
            spotsData.forEach(spot => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>Spot ${spot.index}</td>
                    <td>${spot.lat.toFixed(5)}</td>
                    <td>${spot.lon.toFixed(5)}</td>
                    <td>${spot.section}</td>
                    <td><a href="https://www.google.com/maps?q=${spot.lat},${spot.lon}" target="_blank">View on Google Maps</a></td>
                `;
                spotsBody.appendChild(tr);
            });
        }

        // Display stream details
        function displayStreamDetails() {
            const ratingMap = { 'E': 0, 'D': 1, 'C': 2, 'B': 3, 'A': 4, 'S': 5 };
            const excludedStreams = ['Unknown', 'Central Sands', 'Minnesota', 'Southern WI'];

            // Filter valid data for this stream
            const streamData = sourceData.rows
                .filter(row => {
                    if (row.length < 18) return false;
                    const date = new Date(row[0].replace(/(\d+)\/(\d+)\/(\d+)/, '$3-$1-$2'));
                    const stream = row[2]?.trim() || '';
                    const rating = row[17]?.toUpperCase();
                    const section = row[15]?.trim();
                    const validRating = /^[SABCDE]$/.test(rating);
                    const validStream = !excludedStreams.some(excluded => stream.includes(excluded));
                    return stream === streamName && validRating && validStream && !isNaN(date.getTime());
                })
                .map(row => {
                    const date = new Date(row[0].replace(/(\d+)\/(\d+)\/(\d+)/, '$3-$1-$2'));
                    const month = date.toLocaleString('default', { month: 'long' });
                    const stream = row[2]?.trim() || '';
                    const rating = ratingMap[row[17]?.toUpperCase()] ?? -1;
                    const section = row[15]?.trim().toUpperCase() || 'UNKNOWN';
                    const lat = parseFloat(row[12]);
                    const lon = parseFloat(row[13]);
                    return { month, stream, rating, section, lat, lon, date };
                });

            if (streamData.length === 0) {
                document.getElementById('error').textContent = 'No data found for this stream.';
                return;
            }

            // Overall stats
            const totalVisits = streamData.length;
            const avgRating = streamData.reduce((sum, entry) => sum + entry.rating, 0) / totalVisits;
            const roundedAvg = Math.round(avgRating * 100) / 100;

            const sectionCounts = { LOWER: 0, MIDDLE: 0, UPPER: 0 };
            streamData.forEach(entry => {
                if (entry.section in sectionCounts) sectionCounts[entry.section]++;
                else sectionCounts['UNKNOWN'] = (sectionCounts['UNKNOWN'] || 0) + 1;
            });
            const maxCount = Math.max(sectionCounts.LOWER, sectionCounts.MIDDLE, sectionCounts.UPPER);
            const tieCheck = (sectionCounts.LOWER === maxCount ? 1 : 0) +
                             (sectionCounts.MIDDLE === maxCount ? 1 : 0) +
                             (sectionCounts.UPPER === maxCount ? 1 : 0);
            let mostFishedSection = 'Mixed';
            if (maxCount > 0 && tieCheck === 1) {
                if (sectionCounts.LOWER === maxCount) mostFishedSection = 'Lower';
                else if (sectionCounts.MIDDLE === maxCount) mostFishedSection = 'Middle';
                else if (sectionCounts.UPPER === maxCount) mostFishedSection = 'Upper';
            }

            // April stats
            const aprilData = streamData.filter(entry => entry.month === 'April');
            const aprilSectionCounts = { LOWER: 0, MIDDLE: 0, UPPER: 0 };
            aprilData.forEach(entry => {
                if (entry.section in aprilSectionCounts) aprilSectionCounts[entry.section]++;
                else aprilSectionCounts['UNKNOWN'] = (aprilSectionCounts['UNKNOWN'] || 0) + 1;
            });
            const aprilMaxCount = Math.max(aprilSectionCounts.LOWER, aprilSectionCounts.MIDDLE, aprilSectionCounts.UPPER);
            const aprilTieCheck = (aprilSectionCounts.LOWER === aprilMaxCount ? 1 : 0) +
                                  (aprilSectionCounts.MIDDLE === aprilMaxCount ? 1 : 0) +
                                  (aprilSectionCounts.UPPER === aprilMaxCount ? 1 : 0);
            let aprilSection = aprilData.length > 0 ? 'Mixed' : 'No April data';
            if (aprilMaxCount > 0 && aprilTieCheck === 1) {
                if (aprilSectionCounts.LOWER === aprilMaxCount) aprilSection = 'Lower';
                else if (aprilSectionCounts.MIDDLE === aprilMaxCount) aprilSection = 'Middle';
                else if (aprilSectionCounts.UPPER === aprilMaxCount) aprilSection = 'Upper';
            }

            // Populate overall stats
            document.getElementById('total-visits').textContent = totalVisits;
            document.getElementById('avg-rating').textContent = roundedAvg;
            document.getElementById('most-fished-section').textContent = mostFishedSection;
            document.getElementById('april-section').textContent = aprilSection;

            // Fishing spots (deduplicated, sorted by section: Lower → Middle → Upper, then by latitude within each section)
            const spotsMap = new Map(); // Map to store lat/lon pairs and their associated sections
            streamData.forEach((entry, index) => {
                if (!isNaN(entry.lat) && !isNaN(entry.lon)) {
                    // Round lat/lon to 5 decimal places to avoid floating-point precision issues
                    const lat = Number(entry.lat.toFixed(5));
                    const lon = Number(entry.lon.toFixed(5));
                    const key = `${lat},${lon}`;
                    if (!spotsMap.has(key)) {
                        spotsMap.set(key, { lat, lon, sections: [entry.section] });
                    } else {
                        spotsMap.get(key).sections.push(entry.section);
                    }
                }
            });

            // Process spotsMap to determine the most frequent section for each lat/lon pair
            spotsData = Array.from(spotsMap.values()).map(spot => {
                // Count occurrences of each section for this lat/lon pair
                const sectionCounts = { LOWER: 0, MIDDLE: 0, UPPER: 0, UNKNOWN: 0 };
                spot.sections.forEach(section => {
                    sectionCounts[section] = (sectionCounts[section] || 0) + 1;
                });

                // Find the section with the highest count
                let maxCount = 0;
                let selectedSection = 'UNKNOWN';
                for (const [section, count] of Object.entries(sectionCounts)) {
                    if (count > maxCount) {
                        maxCount = count;
                        selectedSection = section;
                    } else if (count === maxCount) {
                        // In case of a tie, prefer the most downstream section (LOWER > MIDDLE > UPPER)
                        const order = sectionOrder[section] || 5;
                        const currentOrder = sectionOrder[selectedSection] || 5;
                        if (order < currentOrder) {
                            selectedSection = section;
                        }
                    }
                }

                return { lat: spot.lat, lon: spot.lon, section: selectedSection };
            });

            // Sort by section (Lower → Middle → Upper), then by latitude within each section
            spotsData.sort((a, b) => {
                const sectionA = sectionOrder[a.section] || 5;
                const sectionB = sectionOrder[b.section] || 5;
                if (sectionA === sectionB) {
                    // Within the same section, sort by latitude
                    return a.lat - b.lat;
                }
                return sectionA - sectionB;
            });

            // Assign Spot numbers based on sorted order (downstream to upstream)
            spotsData.forEach((spot, idx) => {
                spot.index = idx + 1;
            });

            const spotsBody = document.getElementById('spots-body');
            spotsData.forEach(spot => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>Spot ${spot.index}</td>
                    <td>${spot.lat.toFixed(5)}</td>
                    <td>${spot.lon.toFixed(5)}</td>
                    <td>${spot.section}</td>
                    <td><a href="https://www.google.com/maps?q=${spot.lat},${spot.lon}" target="_blank">View on Google Maps</a></td>
                `;
                spotsBody.appendChild(tr);
            });

            // Set default sort indicator on Section
            document.querySelectorAll('.spots-table th')[3].classList.add('sort-asc');

            document.getElementById('stream-details').style.display = 'block';
        }

        // Initialize
        init();
    </script>
</body>
</html>
